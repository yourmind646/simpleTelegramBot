// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: items.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createItemInstance = `-- name: CreateItemInstance :one
INSERT INTO item_instances (item_def_id, props)
VALUES ($1, $2::jsonb)
RETURNING item_instance_id, item_def_id, props, created_at
`

type CreateItemInstanceParams struct {
	ItemDefID int64
	Column2   []byte
}

func (q *Queries) CreateItemInstance(ctx context.Context, arg CreateItemInstanceParams) (ItemInstance, error) {
	row := q.db.QueryRow(ctx, createItemInstance, arg.ItemDefID, arg.Column2)
	var i ItemInstance
	err := row.Scan(
		&i.ItemInstanceID,
		&i.ItemDefID,
		&i.Props,
		&i.CreatedAt,
	)
	return i, err
}

const createItemInstanceByCode = `-- name: CreateItemInstanceByCode :one
INSERT INTO item_instances (item_def_id, props)
SELECT item_def_id, $2::jsonb
FROM item_defs
WHERE code = $1
RETURNING item_instance_id, item_def_id, props, created_at
`

type CreateItemInstanceByCodeParams struct {
	Code    string
	Column2 []byte
}

func (q *Queries) CreateItemInstanceByCode(ctx context.Context, arg CreateItemInstanceByCodeParams) (ItemInstance, error) {
	row := q.db.QueryRow(ctx, createItemInstanceByCode, arg.Code, arg.Column2)
	var i ItemInstance
	err := row.Scan(
		&i.ItemInstanceID,
		&i.ItemDefID,
		&i.Props,
		&i.CreatedAt,
	)
	return i, err
}

const getItemDefByCode = `-- name: GetItemDefByCode :one
SELECT item_def_id, code, name, category, stackable, base_props, icon_file_key
FROM item_defs
WHERE code = $1
`

func (q *Queries) GetItemDefByCode(ctx context.Context, code string) (ItemDef, error) {
	row := q.db.QueryRow(ctx, getItemDefByCode, code)
	var i ItemDef
	err := row.Scan(
		&i.ItemDefID,
		&i.Code,
		&i.Name,
		&i.Category,
		&i.Stackable,
		&i.BaseProps,
		&i.IconFileKey,
	)
	return i, err
}

const listItemDefs = `-- name: ListItemDefs :many
SELECT item_def_id, code, name, category, stackable, base_props, icon_file_key
FROM item_defs
ORDER BY category, name
`

func (q *Queries) ListItemDefs(ctx context.Context) ([]ItemDef, error) {
	rows, err := q.db.Query(ctx, listItemDefs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemDef
	for rows.Next() {
		var i ItemDef
		if err := rows.Scan(
			&i.ItemDefID,
			&i.Code,
			&i.Name,
			&i.Category,
			&i.Stackable,
			&i.BaseProps,
			&i.IconFileKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertItemDef = `-- name: UpsertItemDef :exec
INSERT INTO item_defs (code, name, category, stackable, base_props, icon_file_key)
VALUES ($1, $2, $3, $4, $5::jsonb, $6)
ON CONFLICT (code) DO UPDATE
SET name = EXCLUDED.name,
    category = EXCLUDED.category,
    stackable = EXCLUDED.stackable,
    base_props = EXCLUDED.base_props,
    icon_file_key = EXCLUDED.icon_file_key
`

type UpsertItemDefParams struct {
	Code        string
	Name        string
	Category    ItemCategoryEnum
	Stackable   bool
	Column5     []byte
	IconFileKey pgtype.Text
}

func (q *Queries) UpsertItemDef(ctx context.Context, arg UpsertItemDefParams) error {
	_, err := q.db.Exec(ctx, upsertItemDef,
		arg.Code,
		arg.Name,
		arg.Category,
		arg.Stackable,
		arg.Column5,
		arg.IconFileKey,
	)
	return err
}
